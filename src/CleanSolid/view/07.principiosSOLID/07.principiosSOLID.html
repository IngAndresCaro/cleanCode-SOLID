<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Los principios SOLID</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            color: #333;
        }

        h1 {
            text-align: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }

        p {
            margin: 0 0 20px;
        }

        ul {
            list-style-type: none;
            padding: 0;
        }

        li {
            margin-bottom: 10px;
        }

        li:before {
            content: "•";
            color: #4CAF50;
            display: inline-block;
            width: 1em;
            margin-left: -1em;
        }
    </style>
</head>

<body>
    <h1>Los principios SOLID</h1>
    <p>Son un conjunto de cinco principios de diseño de software que buscan guiar a los desarrolladores a crear sistemas
        de software más mantenibles, flexibles y escalables. Estos principios fueron introducidos por Robert C. Martin y
        se han convertido en fundamentales en la ingeniería de software. Cada letra de la palabra "SOLID" representa uno
        de estos principios:</p>
    <ul>
        <li>S - Principio de Responsabilidad Única (Single Responsibility Principle): Este principio establece que una
            clase debe tener una única razón para cambiar. En otras palabras, una clase debe tener una única
            responsabilidad. Esto facilita el mantenimiento y evita que los cambios en una parte del código afecten a
            otras partes de manera inesperada.</li>
        <li>O - Principio de Abierto/Cerrado (Open/Closed Principle): Según este principio, las entidades de software
            (como clases, módulos, etc.) deben estar abiertas para la extensión pero cerradas para la modificación. Esto
            significa que se deben poder agregar nuevas funcionalidades o comportamientos sin cambiar el código
            existente.</li>
        <li>L - Principio de Sustitución de Liskov (Liskov Substitution Principle): Este principio establece que los
            objetos de una clase derivada deben poder sustituirse por objetos de la clase base sin afectar la corrección
            del programa. En otras palabras, las clases derivadas deben ser compatibles con las clases base en términos
            de comportamiento.</li>
        <li>I - Principio de Segregación de Interfaces (Interface Segregation Principle): Este principio sugiere que una
            clase no debería verse forzada a implementar interfaces que no utiliza. En lugar de eso, las interfaces
            deben estar diseñadas para ser específicas y contener solo los métodos requeridos por las clases que las
            implementan.</li>
        <li>D - Principio de Inversión de Dependencia (Dependency Inversion Principle): El último principio establece
            que los módulos de alto nivel no deben depender directamente de módulos de bajo nivel. Ambos deben depender
            de abstracciones. Además, las abstracciones no deben depender de los detalles, sino que los detalles deben
            depender de las abstracciones.</li>

    </ul>
</body>

</html>
